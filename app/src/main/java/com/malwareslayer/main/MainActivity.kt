package com.malwareslayer.main

import java.net.*

import android.app.*
import android.content.*

import android.os.Bundle

import android.telephony.SmsManager

import android.util.Log

import android.widget.TextView

import androidx.activity.ComponentActivity

import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.server.application.*
import io.ktor.server.application.Application
import io.ktor.server.engine.*
import io.ktor.server.netty.*
import io.ktor.server.plugins.contentnegotiation.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*

import io.ktor.util.*

import kotlinx.coroutines.*
import kotlinx.serialization.json.Json

import org.mobicents.protocols.ss7.map.api.smstpdu.SmsStatusReportTpdu
import org.mobicents.protocols.ss7.map.api.smstpdu.SmsTpdu
import org.mobicents.protocols.ss7.map.api.smstpdu.SmsTpduType
import org.mobicents.protocols.ss7.map.api.smstpdu.Status

import org.mobicents.protocols.ss7.map.smstpdu.SmsTpduImpl

class MainActivity : ComponentActivity() {

    private lateinit var relativeLayoutTextView: TextView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity)

        relativeLayoutTextView = findViewById(R.id.viewer)

        registerReceiver(broadcast, IntentFilter("com.malwareslayer.main.sending"))
        registerReceiver(broadcast, IntentFilter("com.malwareslayer.main.deliver"))

        CoroutineScope(Dispatchers.IO).launch {
            relativeLayoutTextView.append("Start Server [$hostIpv4Address:8080]\n")

            try {
                serverNetty.start(wait = true)
            } catch (e: Exception) {
                relativeLayoutTextView.append("${e.cause.toString()}: ${e.message}\n")
            }
        }
    }

    override fun onDestroy() {
        relativeLayoutTextView.append("Stopping Server Gracefully\n")

        serverNetty.stop(1000, 1000)

        relativeLayoutTextView.append("Stopping Server Successfully\n")

        super.onDestroy()
    }

    private val serverNetty: ApplicationEngine by lazy {
        embeddedServer(Netty, port = 8080) {
            setup()
        }
    }

    private val hostIpv4Address: String?
        get() {
            return NetworkInterface.getNetworkInterfaces().iterator().asSequence().flatMap { networkInterface ->
                networkInterface.inetAddresses.asSequence().filter { inetAddress ->
                    inetAddress is Inet4Address && inetAddress.isSiteLocalAddress &&
                            !inetAddress.isLoopbackAddress && inetAddress.hostAddress != "127.0.0.1"
                }.map { inetAddress ->
                    inetAddress.hostAddress
                }
            }.firstOrNull()
        }

    private val smsManager: SmsManager = SmsManager.getDefault()

    private val silentSmsPayload: ByteArray =
        byteArrayOf(0x0A, 0x06, 0x03, 0xB0.toByte(), 0xAF.toByte(), 0x82.toByte(), 0x03, 0x06, 0x6A, 0x00, 0x05)

    private val storage: MutableMap<String?, Result> = mutableMapOf()

    private fun Application.setup() {
        install(ContentNegotiation) {
            json(Json {
                prettyPrint = true
                isLenient = true
            })
        }

        routing {
            post("/") {
                val phone: Phone = call.receive<Phone>()

                val sending: Intent = Intent("com.malwareslayer.main.sending")

                sending.putExtra("number", phone.number)

                if (call.attributes.contains(AttributeKey<String>("error"))) {
                    call.respond(HttpStatusCode.Unauthorized, call.attributes[AttributeKey("error")])
                }

                val deliver: Intent = Intent("com.malwareslayer.main.deliver")

                deliver.putExtra("number", phone.number)

                if (!phone.number.startsWith("+") && (phone.number.length <= 10)) {
                    call.respond(HttpStatusCode.BadRequest, "Malformed JSON: Invalid Format Number")
                }

                storage[phone.number] = Result(phone = phone.number, sending = false, deliver = false)

                try {
                    smsManager.sendDataMessage(
                        phone.number, null, 9200, silentSmsPayload,
                        PendingIntent.getBroadcast(
                            this@MainActivity,
                            0x1337,
                            sending,
                            PendingIntent.FLAG_CANCEL_CURRENT or PendingIntent.FLAG_MUTABLE
                        ),
                        PendingIntent.getBroadcast(
                            this@MainActivity,
                            0x1337,
                            deliver,
                            PendingIntent.FLAG_CANCEL_CURRENT or PendingIntent.FLAG_MUTABLE
                        )
                    )

                } catch (e: java.lang.Exception) {
                    call.respond(HttpStatusCode.InternalServerError, "${e.message}")
                }

                val result: Result = Result(phone = phone.number, sending = false, deliver = false)

                runBlocking {
                    val job = launch {
                        var counter: Int = 0

                        while (!storage[phone.number]?.sending!!) {
                            counter += 1

                            Thread.sleep(1000)

                            if (counter > 3) {
                                break
                            }
                        }

                        result.sending = storage[phone.number]?.sending ?: false

                        counter = 0

                        while (!storage[phone.number]?.deliver!!) {
                            counter += 1

                            Thread.sleep(1000)

                            if (counter > 3) {
                                break
                            }
                        }

                        result.deliver = storage[phone.number]?.deliver ?: false
                    }

                    withTimeout(10000) {
                        job.join()
                    }
                }

                var status: String = if (result.deliver) {
                    "ONLINE"
                } else {
                    "OFFLINE"
                }

                if (!result.sending && !result.deliver) {
                    status = "AIRPLANE"
                }

                relativeLayoutTextView.append(
                    "${call.request.local.remoteAddress} ---- ${result.phone} $status"
                )

                call.respond(HttpStatusCode.OK, result)
            }
        }
    }

    private fun hex(bytes: ByteArray) : String {
        val buffer: StringBuilder = StringBuilder()

        for (byte in bytes) {
            buffer.append(String.format("0x%02X ", byte))
        }

        return buffer.toString()
    }

    private val broadcast: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            when (intent?.action) {
                "com.malwareslayer.main.sending" -> {
                    if (intent.hasExtra("number")) {
                        val key: String? = intent.getStringExtra("number")

                        if (resultCode == Activity.RESULT_OK) {
                            storage[key]?.sending = true
                        }
                    }
                }
                "com.malwareslayer.main.deliver" -> {
                    if (intent.hasExtra("pdu") && intent.hasExtra("number")) {
                        val key: String? = intent.getStringExtra("number")
                        val pdu: ByteArray? = intent.getByteArrayExtra("pdu")

                        if (pdu != null && pdu.size > 1) {
                            var result: SmsTpdu? = null

                            try {
                                result = SmsTpduImpl.createInstance(pdu, false, null)
                            } catch (e: Exception) {
                                Log.e("com.malwareslayer.main.deliver", "${e.message}\n")
                            }

                            if (result == null) {
                                try {
                                    result = SmsTpduImpl.createInstance(pdu.copyOfRange(pdu[0] + 1, pdu.size),
                                        false, null
                                    );
                                } catch (e: Exception) {
                                    Log.e("com.malwareslayer.main.deliver", "${e.message}\n")
                                }
                            }

                            if (result != null) {
                                storage[key]?.deliver = (result.smsTpduType.equals(SmsTpduType.SMS_STATUS_REPORT) && ((result as SmsStatusReportTpdu).status.code == Status.SMS_RECEIVED))
                            } else {
                                storage[key]?.deliver = "00".equals(hex(pdu).trim().substring(hex(pdu).trim().length - 2), true);
                            }
                        }
                    }
                }
            }
        }
    }
}